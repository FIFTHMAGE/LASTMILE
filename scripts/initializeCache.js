/**\n * Cache Initialization Script\n * Sets up Redis caching and performs initial cache warm-up\n */\n\nrequire('dotenv').config();\nconst { cacheService } = require('../services/CacheService');\nconst { cacheIntegration } = require('../services/CacheIntegration');\nconst mongoose = require('mongoose');\n\n/**\n * Initialize cache system\n */\nasync function initializeCache() {\n  try {\n    console.log('üöÄ Starting cache initialization...');\n    \n    // Connect to MongoDB first (needed for cache warm-up)\n    if (mongoose.connection.readyState === 0) {\n      await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/lastmile');\n      console.log('üìä Connected to MongoDB for cache initialization');\n    }\n    \n    // Connect to Redis\n    await cacheService.connect();\n    console.log('‚úÖ Connected to Redis cache');\n    \n    // Perform health check\n    const health = await cacheService.healthCheck();\n    if (health.status !== 'healthy') {\n      throw new Error(`Cache health check failed: ${health.error}`);\n    }\n    console.log(`üíö Cache health check passed (latency: ${health.latency})`);\n    \n    // Clear any stale cache data (optional - uncomment if needed)\n    // console.log('üßπ Clearing stale cache data...');\n    // await cacheService.redis.flushdb();\n    \n    // Warm up frequently accessed data\n    console.log('üî• Warming up cache with frequently accessed data...');\n    await cacheIntegration.warmUpFrequentData();\n    \n    // Get cache statistics\n    const stats = await cacheService.getStats();\n    console.log('üìà Cache statistics:', {\n      connected: stats.connected,\n      memoryUsed: stats.memory?.used_memory_human || 'N/A',\n      totalKeys: stats.keyspace?.keys || 0\n    });\n    \n    console.log('üéâ Cache initialization completed successfully!');\n    \n    return {\n      status: 'success',\n      health,\n      stats: cacheIntegration.getPerformanceStats()\n    };\n  } catch (error) {\n    console.error('‚ùå Cache initialization failed:', error);\n    throw error;\n  }\n}\n\n/**\n * Cleanup cache connections\n */\nasync function cleanupCache() {\n  try {\n    console.log('üßπ Cleaning up cache connections...');\n    \n    await cacheService.disconnect();\n    \n    if (mongoose.connection.readyState === 1) {\n      await mongoose.disconnect();\n    }\n    \n    console.log('‚úÖ Cache cleanup completed');\n  } catch (error) {\n    console.error('‚ùå Cache cleanup error:', error);\n  }\n}\n\n/**\n * Cache maintenance tasks\n */\nasync function performCacheMaintenance() {\n  try {\n    console.log('üîß Starting cache maintenance...');\n    \n    // Get current cache statistics\n    const beforeStats = await cacheService.getStats();\n    console.log('üìä Cache stats before maintenance:', {\n      memoryUsed: beforeStats.memory?.used_memory_human || 'N/A',\n      totalKeys: beforeStats.keyspace?.keys || 0\n    });\n    \n    // Clear expired keys (Redis handles this automatically, but we can force it)\n    const expiredKeys = await cacheService.keys('*');\n    let expiredCount = 0;\n    \n    for (const key of expiredKeys) {\n      const ttl = await cacheService.ttl(key.replace(cacheService.keyPrefix, ''));\n      if (ttl === -2) { // Key doesn't exist (expired)\n        expiredCount++;\n      }\n    }\n    \n    // Clear pattern-based stale data (older than 1 hour)\n    const stalePatterns = [\n      'offers:nearby:*',\n      'riders:available:*',\n      'analytics:*'\n    ];\n    \n    let clearedCount = 0;\n    for (const pattern of stalePatterns) {\n      const cleared = await cacheService.clearPattern(pattern);\n      clearedCount += cleared;\n    }\n    \n    // Get updated statistics\n    const afterStats = await cacheService.getStats();\n    \n    console.log('‚úÖ Cache maintenance completed:', {\n      expiredKeys: expiredCount,\n      clearedKeys: clearedCount,\n      memoryAfter: afterStats.memory?.used_memory_human || 'N/A',\n      totalKeysAfter: afterStats.keyspace?.keys || 0\n    });\n    \n    return {\n      expiredKeys: expiredCount,\n      clearedKeys: clearedCount,\n      beforeStats,\n      afterStats\n    };\n  } catch (error) {\n    console.error('‚ùå Cache maintenance error:', error);\n    throw error;\n  }\n}\n\n/**\n * Monitor cache performance\n */\nasync function monitorCachePerformance() {\n  try {\n    console.log('üìä Monitoring cache performance...');\n    \n    const health = await cacheIntegration.healthCheck();\n    const performance = cacheIntegration.getPerformanceStats();\n    \n    const report = {\n      timestamp: new Date(),\n      health: health.status,\n      connected: health.cache?.connected || false,\n      latency: health.cache?.latency || 'N/A',\n      performance: {\n        hitRate: performance.hitRate,\n        errorRate: performance.errorRate,\n        totalRequests: performance.totalRequests,\n        hits: performance.hits,\n        misses: performance.misses,\n        errors: performance.errors\n      }\n    };\n    \n    console.log('üìà Cache Performance Report:', report);\n    \n    // Alert if performance is poor\n    const hitRateNum = parseFloat(performance.hitRate.replace('%', ''));\n    const errorRateNum = parseFloat(performance.errorRate.replace('%', ''));\n    \n    if (hitRateNum < 70) {\n      console.warn('‚ö†Ô∏è  Low cache hit rate detected:', performance.hitRate);\n    }\n    \n    if (errorRateNum > 5) {\n      console.warn('‚ö†Ô∏è  High cache error rate detected:', performance.errorRate);\n    }\n    \n    if (health.status !== 'healthy') {\n      console.error('üö® Cache health check failed!');\n    }\n    \n    return report;\n  } catch (error) {\n    console.error('‚ùå Cache monitoring error:', error);\n    throw error;\n  }\n}\n\n// Handle script execution\nif (require.main === module) {\n  const command = process.argv[2] || 'init';\n  \n  switch (command) {\n    case 'init':\n      initializeCache()\n        .then(() => process.exit(0))\n        .catch(() => process.exit(1));\n      break;\n      \n    case 'cleanup':\n      cleanupCache()\n        .then(() => process.exit(0))\n        .catch(() => process.exit(1));\n      break;\n      \n    case 'maintenance':\n      initializeCache()\n        .then(() => performCacheMaintenance())\n        .then(() => cleanupCache())\n        .then(() => process.exit(0))\n        .catch(() => process.exit(1));\n      break;\n      \n    case 'monitor':\n      initializeCache()\n        .then(() => monitorCachePerformance())\n        .then(() => cleanupCache())\n        .then(() => process.exit(0))\n        .catch(() => process.exit(1));\n      break;\n      \n    default:\n      console.log('Usage: node scripts/initializeCache.js [init|cleanup|maintenance|monitor]');\n      process.exit(1);\n  }\n}\n\nmodule.exports = {\n  initializeCache,\n  cleanupCache,\n  performCacheMaintenance,\n  monitorCachePerformance\n};"